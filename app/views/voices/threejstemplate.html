<!DOCTYPE html>

<html lang="en">
	<head>
		<title>Basic Three.js VR boilerplate</title>
		<meta charset="utf-8">
		<meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
		<style>
			body {
				background-color: #000;
				color: #fff;
				margin: 0px;
				padding: 0;
				overflow: hidden;
			}
		</style>
	</head>

	<body>

	</body>

	<!--
	three.js 3d library
	-->
	<script src="js/three.min.js"></script>
	<script src="js/d3.js"></script>
	<!--
	VRControls.js acquires positional information from connected VR devices and applies the transformations to a three.js camera object.
	 -->
	<script src="js/VRControls.js"></script>

	<!--
	VREffect.js handles stereo camera setup and rendering.
	-->
	<script src="js/VREffect.js"></script>

	<script>
		/*
		Setup three.js WebGL renderer
		*/
		var renderer = new THREE.WebGLRenderer( { antialias: true } );

		/*
		Append the canvas element created by the renderer to document body element.
		*/
		document.body.appendChild( renderer.domElement );

		/*
		Create a three.js scene
		*/
		var scene = new THREE.Scene();

		/*
		Create a three.js camera
		*/
		var camera = new THREE.PerspectiveCamera( 75, window.innerWidth / window.innerHeight, 0, 100 );

		/*
		Apply VR headset orientation and positional to camera.
		*/
		var controls = new THREE.VRControls( camera );

		/*
		Apply VR stereo rendering to renderer
		*/
		var effect = new THREE.VREffect( renderer );
		effect.setSize( window.innerWidth, window.innerHeight );

		/*
		Create 3d objects
		*/
		var geometry = new THREE.BoxGeometry( 0.1, 0.05, 0.1 );

		var material = new THREE.MeshNormalMaterial();

		var cube = new THREE.Mesh( geometry, material );

		
		/*
		Position cube mesh
		*/
		cube.position.z = -0.3;

		/*
		Add cube mesh to your three.js scene
		*/
		scene.add( cube );

		/* royRect */

		 var geometry = new THREE.BoxGeometry( 0.2, 0.1, 0.9 );
		 var material = new THREE.MeshNormalMaterial();
		 var royRect = new THREE.Mesh( geometry, material );
		 royRect.position.x = + 0.3;
		 scene.add(royRect);

 

		/*
		Request animation frame loop function
		*/
		function animate() {
			/*
			Apply rotation to cube mesh
			*/
			cube.rotation.y += 0.01;
			royRect.rotation.z+= 0.05;

			/*
			Update VR headset position and apply to camera.
			*/
			controls.update();

			/*
			Render the scene through the VREffect.
			*/
			effect.render( scene, camera );

			requestAnimationFrame( animate );
		}

		/*
		Kick off animation loop
		*/
		animate();

		/* map stuff*/

		var counties = d3.map();

		var RO_CENTER = [25.0094303, 45.9442858];

		function initGeometry(features) {
			var path = d3.geo.path().projection(d3.geo.mercator().center(RO_CENTER));

			features.forEach(function(feature) {
				if (feature.id === 'IF') {
					// remove Bucharest hole
					feature.geometry.coordinates = feature.geometry.coordinates.slice(0, 1);
				}

				var contour = transformSVGPath(path(feature));

				var county = counties.get(feature.id);
				county.set('contour', contour);
				county.set('name', feature.properties.name);
			});
		}

		/*
		Listen for double click event to enter full-screen VR mode
		*/
		document.body.addEventListener( 'dblclick', function() {
			effect.setFullScreen( true );
		});

		/*
		Listen for keyboard event and zero positional sensor on appropriate keypress.
		*/
		function onkey(event) {
	    event.preventDefault();

	    if (event.keyCode == 90) { // z
	    	controls.zeroSensor();
	    }
	  };

	  window.addEventListener("keydown", onkey, true);


		/*
		Handle window resizes
		*/
		function onWindowResize() {
			camera.aspect = window.innerWidth / window.innerHeight;
			camera.updateProjectionMatrix();

			effect.setSize( window.innerWidth, window.innerHeight );
		}

		window.addEventListener( 'resize', onWindowResize, false );

	</script>
</html>
